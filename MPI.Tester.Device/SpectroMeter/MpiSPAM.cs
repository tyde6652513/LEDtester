using System;
using System.Collections.Generic;
using System.Text;
using System.Runtime.InteropServices;
using System.Collections;

namespace MPI.Tester.Device.SpectroMeter
{
	public enum EIntegrateMode : int
	{
		RECTANGULAR		= 1,
		TRAPEZOID			= 2,
		SIMPSONS				= 3,
	}

	public class Coef 
	{
		public static double[]  LuminousEfficiencyFunction1988Per1nm  = new double[401] {
								0.00020000,	0.00022821,	0.00026109,	0.00029936,	0.00034387,	0.00039556,	0.00045544,	0.00052462,	0.00060428,	0.00069565,
								0.00080000,	0.00091635,	0.00104770,	0.00119550,	0.00136110,	0.00154570,	0.00175080,	0.00187760,	0.00222730,	0.00250110,
								0.00280000,	0.00311590,	0.00345760,	0.00382680,	0.00422560,	0.00465620,	0.00512160,	0.00562480,	0.00616950,	0.00675970,
								0.00740000,	0.00814510,	0.00895550,	0.00983220,	0.01077400,	0.01177900,	0.01284200,	0.01395600,	0.01511100,	0.01629700,
								0.01750000,	0.01858200,	0.01964500,	0.02068300,	0.02169400,	0.02267800,	0.02363600,	0.02457200,	0.02549000,	0.02639700,
								0.02730000,	0.02833500,	0.02938300,	0.03044200,	0.03151000,	0.03258400,	0.03366100,	0.03473500,	0.03580300,	0.03686000,
								0.03790000,	0.03883800,	0.03975200,	0.04064600,	0.04152400,	0.04239100,	0.04325200,	0.04411600,	0.04499000,	0.04588100,
								0.04680000,	0.04774300,	0.04873300,	0.04978500,	0.05091000,	0.05212200,	0.05343500,	0.05486400,	0.05642400,	0.05813100,
								0.06000000,	0.06260197,	0.06527752,	0.06804208,	0.07091109,	0.07390000,	0.07701600,	0.08026640,	0.08366680,	0.08723280,
								0.09098000,	0.09491755,	0.09904584,	0.10336740,	0.10788460,	0.11260000,	0.11753200,	0.12267440,	0.12799280,	0.13345280,
								0.13902000,	0.14467640,	0.15046930,	0.15646190,	0.16271770,	0.16930000,	0.17624310,	0.18355810,	0.19127350,	0.19941800,
								0.20802000,	0.21711990,	0.22673450,	0.23685710,	0.24748120,	0.25860000,	0.27018490,	0.28229390,	0.29505050,	0.30857800,
								0.32300000,	0.33840210,	0.35468580,	0.37169860,	0.38928750,	0.40730000,	0.42562990,	0.44430960,	0.46339440,	0.48293950,
								0.50300000,	0.52356930,	0.54451200,	0.56569000,	0.58696530,	0.60820000,	0.62934560,	0.65030680,	0.67087520,	0.69084240,
								0.71000000,	0.72818520,	0.74546360,	0.76196940,	0.77783680,	0.79320000,	0.80811040,	0.82249620,	0.83630680,	0.84949160,
								0.86200000,	0.87381080,	0.88496240,	0.89549360,	0.90544320,	0.91485010,	0.92373480,	0.93209240,	0.93992260,	0.94722520,
								0.95400000,	0.96025610,	0.96600740,	0.97126060,	0.97602250,	0.98030000,	0.98409240,	0.98741820,	0.99031280,	0.99281160,
								0.99495010,	0.99671080,	0.99809830,	0.99911200,	0.99974820,	1.00000000,	0.99985670,	0.99930460,	0.99832550,	0.99689870,
								0.99500000,	0.99260050,	0.98974260,	0.98644440,	0.98272410,	0.97860000,	0.97408370,	0.96917120,	0.96385680,	0.95813490,
								0.95200000,	0.94545040,	0.93849920,	0.93116280,	0.92345760,	0.91540000,	0.90700640,	0.89827720,	0.88920480,	0.87978160,
								0.87000000,	0.85986130,	0.84939200,	0.83862200,	0.82758130,	0.81630000,	0.80479470,	0.79308200,	0.78119200,	0.76915470,
								0.75700000,	0.74475410,	0.73242240,	0.72000360,	0.70749650,	0.69490000,	0.68221920,	0.66947160,	0.65667440,	0.64384480,
								0.63100000,	0.61815550,	0.60531440,	0.59247560,	0.57963790,	0.56680000,	0.55396110,	0.54113720,	0.52835280,	0.51563230,
								0.50300000,	0.49046880,	0.47803040,	0.46567760,	0.45340320,	0.44120000,	0.42908000,	0.41703600,	0.40503200,	0.39303200,
								0.38100000,	0.36891840,	0.35682720,	0.34477680,	0.33281760,	0.32100000,	0.30933810,	0.29785040,	0.28659360,	0.27562450,
								0.26500000,	0.25476320,	0.24488960,	0.23533440,	0.22605280,	0.21700000,	0.20816160,	0.19954880,	0.19115520,	0.18297440,
								0.17500000,	0.16722350,	0.15964640,	0.15227760,	0.14512590,	0.13820000,	0.13150030,	0.12502480,	0.11877920,	0.11276910,
								0.10700000,	0.10147620,	0.09618864,	0.09112296,	0.08626485,	0.08160000,	0.07712064,	0.07282552,	0.06871008,	0.06476976,
								0.06100000,	0.05739621,	0.05395504,	0.05067376,	0.04754965,	0.04458000,	0.04175872,	0.03908496,	0.03656384,	0.03420048,
								0.03200000,	0.02996261,	0.02807664,	0.02632936,	0.02470805,	0.02320000,	0.02180077,	0.02050112,	0.01928108,	0.01812069,
								0.01700000,	0.01590379,	0.01483718,	0.01381068,	0.01283478,	0.01192000,	0.01106831,	0.01027339,	0.00953331,	0.00884616,
								0.00821000,	0.00762378,	0.00708542,	0.00659148,	0.00613849,	0.00572300,	0.00534306,	0.00499580,	0.00467640,	0.00438008,
								0.00410200,	0.00383845,	0.00358910,	0.00335422,	0.00313409,	0.00292900,	0.00273814,	0.00255988,	0.00239324,	0.00223728,
								0.00209100,	0.00195359,	0.00182458,	0.00170358,	0.00159019,	0.00148400,	0.00138450,	0.00129127,	0.00120409,	0.00112274,
								0.00104700,	0.00097659,	0.00091111,	0.00085013,	0.00079324,	0.00074000,	0.00069008,	0.00064331,	0.00059950,	0.00055845,
								0.00052000,	0.00048391,	0.00045005,	0.00041835,	0.00038872,	0.00036110,	0.00033538,	0.00031144,	0.00028917,	0.00026845,
								0.00024920,	0.00023130,	0.00021469,	0.00019929,	0.00018505,	0.00017190,	0.00015978,	0.00014860,	0.00013830,	0.00012879,
								0.00012000,	0.00011186,	0.00010432,	0.00009734,	0.00009085,	0.00008480,	0.00007915,	0.00007386,	0.00006892,	0.00006430,
								0.00006000,	0.00005598,	0.00005223,	0.00004872,	0.00004545,	0.00004240,	0.00003956,	0.00003692,	0.00003445,	0.00003215,
								0.00003000,	0.00002799,	0.00002611,	0.00002436,	0.00002272,	0.00002120,	0.00001978,	0.00001845,	0.00001722,	0.00001606,
								0.00001499,};

		public static double[] LuminousEfficiencyFunction1988Per5nm = new double[81] {
								0.00020000,	0.00039556,	0.00080000,	0.00154570,	0.00280000,	0.00465620,	0.00740000,	0.01177900,	0.01750000,	0.02267800,
								0.02730000,	0.03258400,	0.03790000,	0.04239100,	0.04680000,	0.05212200,	0.06000000,	0.07390000,	0.09098000,	0.11260000,
								0.13902000,	0.16930000,	0.20802000,	0.25860000,	0.32300000,	0.40730000,	0.50300000,	0.60820000,	0.71000000,	0.79320000,
								0.86200000,	0.91485010,	0.95400000,	0.98030000,	0.99495010,	1.00000000,	0.99500000,	0.97860000,	0.95200000,	0.91540000,
								0.87000000,	0.81630000,	0.75700000,	0.69490000,	0.63100000,	0.56680000,	0.50300000,	0.44120000,	0.38100000,	0.32100000,
								0.26500000,	0.21700000,	0.17500000,	0.13820000,	0.10700000,	0.08160000,	0.06100000,	0.04458000,	0.03200000,	0.02320000,
								0.01700000,	0.01192000,	0.00821000,	0.00572300,	0.00410200,	0.00292900,	0.00209100,	0.00148400,	0.00104700,	0.00074000,
								0.00052000,	0.00036110,	0.00024920,	0.00017190,	0.00012000,	0.00008480,	0.00006000,	0.00004240,	0.00003000,	0.00002120,
								0.00001499,};

		public static double[] yBarPer5nm = new double[] {
								0.0000,	0.0001,	0.0001,	0.0002,	0.0004,	0.0006,	0.0012,	0.0022,	0.0040,	0.0073,
								0.0116,	0.0168,	0.0230,	0.0298,	0.0380,	0.0480,	0.0600,	0.0739,	0.0910,	0.1126,
								0.1390,	0.1693,	0.2080,	0.2586,	0.3230,	0.4073,	0.5030,	0.6082,	0.7100,	0.7932,
								0.8620,	0.9149,	0.9540,	0.9803,	0.9950,	1.0000,	0.9950,	0.9786,	0.9520,	0.9154,
								0.8700,	0.8163,	0.7570,	0.6949,	0.6310,	0.5668,	0.5030,	0.4412,	0.3810,	0.3210,
								0.2650,	0.2170,	0.1750,	0.1382,	0.1070,	0.0816,	0.0610,	0.0446,	0.0320,	0.0232,
								0.0170,	0.0119,	0.0082,	0.0057,	0.0041,	0.0029,	0.0021,	0.0015,	0.0010,	0.0007,
								0.0005,	0.0004,	0.0002,	0.0002,	0.0001,	0.0001,	0.0001, 0.0000, 0.0000, 0.0000,
								0.0000,	};

		public static double[] PDResponseByLag = new double[] {

								0.00000000,	0.00000000,	0.00000000,	0.00000000,	0.00000000,	0.00000000,	0.00000000,	0.00000000,	0.00000000,	0.00000000,
								0.00000000,	0.00000000,	0.00000000,	0.00000000,	0.00000000,	0.00000000,	0.00000000,	0.00000000,	0.00000000,	0.00000000,
								0.00820000,	0.00851490,	0.00882980,	0.00914470,	0.00945960,	0.00977450,	0.01008940,	0.01040430,	0.01071920,	0.01103410,
								0.01134900,	0.01196970,	0.01259040,	0.01321110,	0.01383180,	0.01445250,	0.01507320,	0.01569390,	0.01631460,	0.01693530,
								0.01755600,	0.01831300,	0.01907000,	0.01982700,	0.02058400,	0.02134100,	0.02209800,	0.02285500,	0.02361200,	0.02436900,
								0.02512600,	0.02620560,	0.02728520,	0.02836480,	0.02944440,	0.03052400,	0.03160360,	0.03268320,	0.03376280,	0.03484240,
								0.03592200,	0.03739300,	0.03886400,	0.04033500,	0.04180600,	0.04327700,	0.04474800,	0.04621900,	0.04769000,	0.04916100,
								0.05063200,	0.05270780,	0.05478360,	0.05685940,	0.05893520,	0.06101100,	0.06308680,	0.06516260,	0.06723840,	0.06931420,
								0.07139000,	0.07443490,	0.07747980,	0.08052470,	0.08356960,	0.08661450,	0.08965940,	0.09270430,	0.09574920,	0.09879410,
								0.10183900,	0.10819120,	0.11454340,	0.12089560,	0.12724780,	0.13360000,	0.13995220,	0.14630440,	0.15265660,	0.15900880,
								0.16536100,	0.17683830,	0.18831560,	0.19979290,	0.21127020,	0.22274750,	0.23422480,	0.24570210,	0.25717940,	0.26865670,
								0.28013400,	0.29674180,	0.31334960,	0.32995740,	0.34656520,	0.36317300,	0.37978080,	0.39638860,	0.41299640,	0.42960420,
								0.44621200,	0.46406310,	0.48191420,	0.49976530,	0.51761640,	0.53546750,	0.55331860,	0.57116970,	0.58902080,	0.60687190,
								0.62472300,	0.64093570,	0.65714840,	0.67336110,	0.68957380,	0.70578650,	0.72199920,	0.73821190,	0.75442460,	0.77063730,
								0.78685000,	0.79853020,	0.81021040,	0.82189060,	0.83357080,	0.84525100,	0.85693120,	0.86861140,	0.88029160,	0.89197180,
								0.90365200,	0.91097900,	0.91830600,	0.92563300,	0.93296000,	0.94028700,	0.94761400,	0.95494100,	0.96226800,	0.96959500,
								0.97692200,	0.97905700,	0.98119200,	0.98332700,	0.98546200,	0.98759700,	0.98973200,	0.99186700,	0.99400200,	0.99613700,
								0.99827200,	0.99537810,	0.99248420,	0.98959030,	0.98669640,	0.98380250,	0.98090860,	0.97801470,	0.97512080,	0.97222690,
								0.96933300,	0.96676400,	0.96419500,	0.96162600,	0.95905700,	0.95648800,	0.95391900,	0.95135000,	0.94878100,	0.94621200,
								0.94364300,	0.93458020,	0.92551740,	0.91645460,	0.90739180,	0.89832900,	0.88926620,	0.88020340,	0.87114060,	0.86207780,
								0.85301500,	0.84235590,	0.83169680,	0.82103770,	0.81037860,	0.79971950,	0.78906040,	0.77840130,	0.76774220,	0.75708310,
								0.74642400,	0.73366990,	0.72091580,	0.70816170,	0.69540760,	0.68265350,	0.66989940,	0.65714530,	0.64439120,	0.63163710,
								0.61888300,	0.60530920,	0.59173540,	0.57816160,	0.56458780,	0.55101400,	0.53744020,	0.52386640,	0.51029260,	0.49671880,
								0.48314500,	0.47048080,	0.45781660,	0.44515240,	0.43248820,	0.41982400,	0.40715980,	0.39449560,	0.38183140,	0.36916720,
								0.35650300,	0.34576520,	0.33502740,	0.32428960,	0.31355180,	0.30281400,	0.29207620,	0.28133840,	0.27060060,	0.25986280,
								0.24912500,	0.24095040,	0.23277580,	0.22460120,	0.21642660,	0.20825200,	0.20007740,	0.19190280,	0.18372820,	0.17555360,
								0.16737900,	0.16146000,	0.15554100,	0.14962200,	0.14370300,	0.13778400,	0.13186500,	0.12594600,	0.12002700,	0.11410800,
								0.10818900,	0.10405150,	0.09991400,	0.09577650,	0.09163900,	0.08750150,	0.08336400,	0.07922650,	0.07508900,	0.07095150,
								0.06681400,	0.06410190,	0.06138980,	0.05867770,	0.05596560,	0.05325350,	0.05054140,	0.04782930,	0.04511720,	0.04240510,
								0.03969300,	0.03801760,	0.03634220,	0.03466680,	0.03299140,	0.03131600,	0.02964060,	0.02796520,	0.02628980,	0.02461440,
								0.02293900,	0.02190990,	0.02088080,	0.01985170,	0.01882260,	0.01779350,	0.01676440,	0.01573530,	0.01470620,	0.01367710,
								0.01264800,	0.01206640,	0.01148480,	0.01090320,	0.01032160,	0.00974000,	0.00915840,	0.00857680,	0.00799520,	0.00741360,
								0.00683200,	0.00652010,	0.00620820,	0.00589630,	0.00558440,	0.00527250,	0.00496060,	0.00464870,	0.00433680,	0.00402490,
								0.00371300,	0.00354970,	0.00338640,	0.00322310,	0.00305980,	0.00289650,	0.00273320,	0.00256990,	0.00240660,	0.00224330,
								0.00208000,	0.00199300,	0.00190600,	0.00181900,	0.00173200,	0.00164500,	0.00155800,	0.00147100,	0.00138400,	0.00129700,
								0.00121000,	0.00116570,	0.00112140,	0.00107710,	0.00103280,	0.00098850,	0.00094420,	0.00089990,	0.00085560,	0.00081130,
								0.00076700,	0.00074430,	0.00072160,	0.00069890,	0.00067620,	0.00065350,	0.00063080,	0.00060810,	0.00058540,	0.00056270,
								0.00054000,	0.00052700,	0.00051400,	0.00050100,	0.00048800,	0.00047500,	0.00046200,	0.00044900,	0.00043600,	0.00042300,
								0.00041000,	0.00040240,	0.00039480,	0.00038720,	0.00037960,	0.00037200,	0.00036440,	0.00035680,	0.00034920,	0.00034160,
								0.00033400,	0.00032960,	0.00032520,	0.00032080,	0.00031640,	0.00031200,	0.00030760,	0.00030320,	0.00029880,	0.00029440,
								0.00029000, };

        public static double[] PDResponseOptimumPer10nm = new double[41] { 
                                0.000000,   0.000000,   0.001296,   0.002118,   0.003645,   0.005648,   0.008390,   0.012636,   0.018987,   0.029188,
                                0.050148,   0.088355,   0.144239,   0.208166,   0.267699,   0.315281,   0.344357,   0.357114,   0.356320,   0.342357,
                                0.315336,   0.274454,   0.224786,   0.174657,   0.127322,   0.088236,   0.059515,   0.038015,   0.022669,   0.012945,
                                0.007163,   0.003779,   0.001995,   0.001087,   0.000640,   0.000423,   0.000324    ,0.000279,  0.000231,   0.000168,
                                0.000155,   };

        public static double[] PDResponseITRIPer10nm = new double[41] { 
                                0.0000,	0.0000,	0.0003,	0.0027,	0.0058,	0.0139,	0.0261,	0.0444,	0.0693,	0.1078,
                                0.1848,	0.3273,	0.5142,	0.6921,	0.8315,	0.9311,	0.9858,	1.0000,	0.9823,	0.9291,
                                0.8381,	0.7139,	0.5673,	0.4238,	0.2979,	0.1977,	0.1246,	0.0740,	0.0421,	0.0231,
                                0.0120,	0.0060,	0.0033,	0.0015,	0.0007,	0.0003,	0.0002,	0.0000,	0.0001,	0.0000,
                                0.0000,     };

							//    0.00000000,	0.00000000,	0.00000000,	0.00000000,	0.00000000,	0.00000000,	0.00000000,	0.00000000,	0.00000000,	0.00000000,
							//    0.00000000,	0.00000000,	0.00000000,	0.00000000,	0.00000000,	0.00000000,	0.00000000,	0.00000000,	0.00000000,	0.00000000,
							//    0.00820000,	0.00837729,	0.00858516,	0.00882361,	0.00909264,	0.00939225,	0.00972244,	0.01008321,	0.01047456,	0.01089649,
							//    0.01134900,	0.01183209,	0.01234576,	0.01289001,	0.01346484,	0.01407025,	0.01470624,	0.01537281,	0.01606996,	0.01679769,
							//    0.01755600,	0.01825167,	0.01896096,	0.01968389,	0.02042044,	0.02117063,	0.02193444,	0.02271189,	0.02350296,	0.02430767,
							//    0.02512600,	0.02606043,	0.02702712,	0.02802607,	0.02905728,	0.03012075,	0.03121648,	0.03234447,	0.03350472,	0.03469723,
							//    0.03592200,	0.03721687,	0.03855088,	0.03992403,	0.04133632,	0.04278775,	0.04427832,	0.04580803,	0.04737688,	0.04898487,
							//    0.05063200,	0.05243564,	0.05429976,	0.05622436,	0.05820944,	0.06025500,	0.06236104,	0.06452756,	0.06675456,	0.06904204,
							//    0.07139000,	0.07399881,	0.07670452,	0.07950715,	0.08240668,	0.08540313,	0.08849648,	0.09168675,	0.09497392,	0.09835801,
							//    0.10183900,	0.10670292,	0.11189756,	0.11742294,	0.12327904,	0.12946588,	0.13598344,	0.14283174,	0.15001076,	0.15752052,
							//    0.16536100,	0.17453201,	0.18421552,	0.19441155,	0.20512008,	0.21634113,	0.22807468,	0.24032075,	0.25307932,	0.26635041,
							//    0.28013400,	0.29443308,	0.30924520,	0.32457038,	0.34040860,	0.35675988,	0.37362420,	0.39100158,	0.40889200,	0.42729548,
							//    0.44621200,	0.46350362,	0.48091956,	0.49845984,	0.51612444,	0.53391338,	0.55182664,	0.56986424,	0.58802616,	0.60631242,
							//    0.62472300,	0.64167298,	0.65845912,	0.67508142,	0.69153988,	0.70783450,	0.72396528,	0.73993222,	0.75573532,	0.77137458,
							//    0.78685000,	0.80056983,	0.81383640,	0.82664973,	0.83900980,	0.85091663,	0.86237020,	0.87337053,	0.88391760,	0.89401143,
							//    0.90365200,	0.91293794,	0.92178856,	0.93020386,	0.93818384,	0.94572850,	0.95283784,	0.95951186,	0.96575056,	0.97155394,
							//    0.97692200,	0.98139340,	0.98534560,	0.98877860,	0.99169240,	0.99408700,	0.99596240,	0.99731860,	0.99815560,	0.99847340,
							//    0.99827200,	0.99764111,	0.99650732,	0.99487065,	0.99273108,	0.99008863,	0.98694328,	0.98329505,	0.97914392,	0.97448991,
							//    0.96933300,	0.96661780,	0.96393508,	0.96128486,	0.95866712,	0.95608188,	0.95352912,	0.95100886,	0.94852108,	0.94606580,
							//    0.94364300,	0.93750241,	0.93071244,	0.92327309,	0.91518436,	0.90644625,	0.89705876,	0.88702189,	0.87633564,	0.86500001,
							//    0.85301500,	0.84307424,	0.83297384,	0.82271382,	0.81229416,	0.80171488,	0.79097596,	0.78007742,	0.76901924,	0.75780144,
							//    0.74642400,	0.73461265,	0.72259180,	0.71036145,	0.69792160,	0.68527225,	0.67241340,	0.65934505,	0.64606720,	0.63257985,
							//    0.61888300,	0.60567807,	0.59239116,	0.57902229,	0.56557144,	0.55203863,	0.53842384,	0.52472709,	0.51094836,	0.49708767,
							//    0.48314500,	0.47007148,	0.45708892,	0.44419732,	0.43139668,	0.41868700,	0.40606828,	0.39354052,	0.38110372,	0.36875788,
							//    0.35650300,	0.34489832,	0.33348628,	0.32226688,	0.31124012,	0.30040600,	0.28976452,	0.27931568,	0.26905948,	0.25899592,
							//    0.24912500,	0.23979696,	0.23072524,	0.22190984,	0.21335076,	0.20504800,	0.19700156,	0.18921144,	0.18167764,	0.17440016,
							//    0.16737900,	0.16044498,	0.15373652,	0.14725362,	0.14099628,	0.13496450,	0.12915828,	0.12357762,	0.11822252,	0.11309298,
							//    0.10818900,	0.10324983,	0.09848880,	0.09390593,	0.08950120,	0.08527463,	0.08122620,	0.07735593,	0.07366380,	0.07014983,
							//    0.06681400,	0.06346047,	0.06024948,	0.05718103,	0.05425512,	0.05147175,	0.04883092,	0.04633263,	0.04397688,	0.04176367,
							//    0.03969300,	0.03755109,	0.03551284,	0.03357827,	0.03174736,	0.03002013,	0.02839656,	0.02687667,	0.02546044,	0.02414789,
							//    0.02293900,	0.02161907,	0.02036376,	0.01917309,	0.01804704,	0.01698563,	0.01598884,	0.01505669,	0.01418916,	0.01338627,
							//    0.01264800,	0.01186503,	0.01112680,	0.01043333,	0.00978460,	0.00918063,	0.00862140,	0.00810693,	0.00763720,	0.00721223,
							//    0.00683200,	0.00639874,	0.00599244,	0.00561312,	0.00526076,	0.00493538,	0.00463696,	0.00436552,	0.00412104,	0.00390354,
							//    0.00371300,	0.00348283,	0.00326752,	0.00306707,	0.00288148,	0.00271075,	0.00255488,	0.00241387,	0.00228772,	0.00217643,
							//    0.00208000,	0.00195867,	0.00184496,	0.00173889,	0.00164044,	0.00154963,	0.00146644,	0.00139089,	0.00132296,	0.00126267,
							//    0.00121000,	0.00114649,	0.00108724,	0.00103227,	0.00098156,	0.00093513,	0.00089296,	0.00085507,	0.00082144,	0.00079209,
							//    0.00076700,	0.00073458,	0.00070432,	0.00067622,	0.00065028,	0.00062650,	0.00060488,	0.00058542,	0.00056812,	0.00055298,
							//    0.00054000,	0.00052264,	0.00050624,	0.00049082,	0.00047636,	0.00046288,	0.00045036,	0.00043882,	0.00042824,	0.00041864,
							//    0.00041000,	0.00039997,	0.00039048,	0.00038153,	0.00037312,	0.00036525,	0.00035792,	0.00035113,	0.00034488,	0.00033917,
							//    0.00033400,	0.00032816,	0.00032264,	0.00031744,	0.00031256,	0.00030800,	0.00030376,	0.00029984,	0.00029624,	0.00029296,
							//0.00029000 };

									//0.00000000,	0.00000000,	0.00000000,	0.00000000,	0.00000000,	0.00000000,	0.00000000,	0.00000000,	0.00000000,	0.00000000,
									//0.00000000,	0.00000000,	0.00000000,	0.00000000,	0.00000000,	0.00000000,	0.00000000,	0.00000000,	0.00000000,	0.00000000,
									//0.00821419,	0.00839179,	0.00860002,	0.00883888,	0.00910838,	0.00940851,	0.00973927,	0.01010066,	0.01049269,	0.01091535,
									//0.01136865,	0.01192898,	0.01250297,	0.01309061,	0.01369190,	0.01430685,	0.01493545,	0.01557770,	0.01623361,	0.01690317,
									//0.01758639,	0.01819928,	0.01884448,	0.01952200,	0.02023184,	0.02097399,	0.02174846,	0.02255525,	0.02339435,	0.02426576,
									//0.02516949,	0.02607453,	0.02701877,	0.02800222,	0.02902487,	0.03008674,	0.03118781,	0.03232809,	0.03350758,	0.03472628,
									//0.03598418,	0.03718510,	0.03844660,	0.03976868,	0.04115135,	0.04259460,	0.04409844,	0.04566287,	0.04728787,	0.04897347,
									//0.05071964,	0.05236219,	0.05410181,	0.05593851,	0.05787228,	0.05990314,	0.06203107,	0.06425608,	0.06657817,	0.06899733,
									//0.07151358,	0.07307288,	0.07496350,	0.07718541,	0.07973863,	0.08262315,	0.08583897,	0.08938609,	0.09326452,	0.09747425,
									//0.10201528,	0.10606819,	0.11063450,	0.11571420,	0.12130730,	0.12741380,	0.13403369,	0.14116698,	0.14881367,	0.15697376,
									//0.16564724,	0.17483168,	0.18453007,	0.19474239,	0.20546865,	0.21670885,	0.22846298,	0.24073106,	0.25351307,	0.26680902,
									//0.28061891,	0.29669500,	0.31289564,	0.32922083,	0.34567056,	0.36224483,	0.37894365,	0.39576702,	0.41271493,	0.42978739,
									//0.44698439,	0.46560495,	0.48406138,	0.50235369,	0.52048187,	0.53844593,	0.55624587,	0.57388169,	0.59135338,	0.60866095,
									//0.62580439,	0.64408831,	0.66191819,	0.67929405,	0.69621586,	0.71268364,	0.72869739,	0.74425710,	0.75936278,	0.77401442,
									//0.78821203,	0.80187478,	0.81510146,	0.82789206,	0.84024659,	0.85216504,	0.86364742,	0.87469373,	0.88530397,	0.89547813,
									//0.90521621,	0.91489634,	0.92405637,	0.93269630,	0.94081613,	0.94841586,	0.95549550,	0.96205503,	0.96809447,	0.97361380,
									//0.97861304,	0.98301866,	0.98692052,	0.99031862,	0.99321295,	0.99560353,	0.99749034,	0.99887340,	0.99975269,	1.00012823,
									//1.00000000,	0.99936801,	0.99823227,	0.99659276,	0.99444949,	0.99180246,	0.98865167,	0.98499712,	0.98083881,	0.97617674,
									//0.97101091,	0.96829100,	0.96560364,	0.96294883,	0.96032656,	0.95773684,	0.95517967,	0.95265504,	0.95016296,	0.94770343,
									//0.94527644,	0.93912522,	0.93232349,	0.92487127,	0.91676854,	0.90801530,	0.89861156,	0.88855732,	0.87785257,	0.86649732,
									//0.85449156,	0.84453359,	0.83441571,	0.82413793,	0.81370023,	0.80310264,	0.79234513,	0.78142772,	0.77035041,	0.75911318,
									//0.74771605,	0.73588426,	0.72384260,	0.71159108,	0.69912970,	0.68645845,	0.67357734,	0.66048637,	0.64718554,	0.63367484,
									//0.61995428,	0.60672649,	0.59341658,	0.58002457,	0.56655044,	0.55299420,	0.53935585,	0.52563538,	0.51183281,	0.49794812,
									//0.48398132,	0.47088517,	0.45788014,	0.44496622,	0.43214342,	0.41941174,	0.40677118,	0.39422174,	0.38176341,	0.36939620,
									//0.35712010,	0.34549534,	0.33406354,	0.32282472,	0.31177887,	0.30092600,	0.29026610,	0.27979917,	0.26952522,	0.25944424,
									//0.24955623,	0.24021205,	0.23112462,	0.22229396,	0.21372007,	0.20540294,	0.19734257,	0.18953896,	0.18199212,	0.17470205,
									//0.16766873,	0.16072271,	0.15400264,	0.14750851,	0.14124034,	0.13519812,	0.12938185,	0.12379153,	0.11842716,	0.11328874,
									//0.10837627,	0.10342855,	0.09865928,	0.09406848,	0.08965613,	0.08542223,	0.08136680,	0.07748983,	0.07379131,	0.07027125,
									//0.06692965,	0.06357032,	0.06035377,	0.05728001,	0.05434904,	0.05156085,	0.04891545,	0.04641283,	0.04405300,	0.04183596,
									//0.03976171,	0.03761609,	0.03557431,	0.03363639,	0.03180231,	0.03007209,	0.02844571,	0.02692319,	0.02550451,	0.02418968,
									//0.02297871,	0.02165649,	0.02039901,	0.01920627,	0.01807828,	0.01701503,	0.01601652,	0.01508275,	0.01421372,	0.01340944,
									//0.01266989,	0.01188556,	0.01114606,	0.01045138,	0.00980154,	0.00919652,	0.00863632,	0.00812096,	0.00765042,	0.00722471,
									//0.00684383,	0.00640981,	0.00600281,	0.00562283,	0.00526987,	0.00494392,	0.00464499,	0.00437307,	0.00412817,	0.00391029,
									//0.00371943,	0.00348886,	0.00327318,	0.00307238,	0.00288647,	0.00271544,	0.00255930,	0.00241805,	0.00229168,	0.00218020,
									//0.00208360,	0.00196206,	0.00184815,	0.00174189,	0.00164328,	0.00155231,	0.00146898,	0.00139329,	0.00132525,	0.00126485,
									//0.00121209,	0.00114847,	0.00108912,	0.00103405,	0.00098326,	0.00093674,	0.00089451,	0.00085655,	0.00082286,	0.00079346,
									//0.00076833,	0.00073585,	0.00070554,	0.00067739,	0.00065141,	0.00062758,	0.00060593,	0.00058643,	0.00056910,	0.00055394,
									//0.00054093,	0.00052354,	0.00050712,	0.00049166,	0.00047718,	0.00046368,	0.00045114,	0.00043957,	0.00042898,	0.00041936,
									//0.00041071,	0.00040066,	0.00039116,	0.00038219,	0.00037377,	0.00036588,	0.00035854,	0.00035174,	0.00034548,	0.00033976,
									//0.00033458,	0.00032873,	0.00032320,	0.00031799,	0.00031310,	0.00030853,	0.00030429,	0.00030036,	0.00029675,	0.00029347,
									//0.00029050, };


									//0.00000000,	0.00000000,	0.00000000,	0.00000000,	0.00000000,	0.00000000,	0.00000000,	0.00000000,	0.00000000,	0.00000000,
									//0.00000000,	0.00000000,	0.00000000,	0.00000000,	0.00000000,	0.00000000,	0.00000000,	0.00000000,	0.00000000,	0.00000000,
									//0.00820000,	0.00837729,	0.00858516,	0.00882361,	0.00909264,	0.00939225,	0.00972244,	0.01008321,	0.01047456,	0.01089649,
									//0.01134900,	0.01183209,	0.01234576,	0.01289001,	0.01346484,	0.01407025,	0.01470624,	0.01537281,	0.01606996,	0.01679769,
									//0.01755600,	0.01825167,	0.01896096,	0.01968389,	0.02042044,	0.02117063,	0.02193444,	0.02271189,	0.02350296,	0.02430767,
									//0.02512600,	0.02606043,	0.02702712,	0.02802607,	0.02905728,	0.03012075,	0.03121648,	0.03234447,	0.03350472,	0.03469723,
									//0.03592200,	0.03721687,	0.03855088,	0.03992403,	0.04133632,	0.04278775,	0.04427832,	0.04580803,	0.04737688,	0.04898487,
									//0.05063200,	0.05243564,	0.05429976,	0.05622436,	0.05820944,	0.06025500,	0.06236104,	0.06452756,	0.06675456,	0.06904204,
									//0.07139000,	0.07399881,	0.07670452,	0.07950715,	0.08240668,	0.08540313,	0.08849648,	0.09168675,	0.09497392,	0.09835801,
									//0.10183900,	0.10670292,	0.11189756,	0.11742294,	0.12327904,	0.12946588,	0.13598344,	0.14283174,	0.15001076,	0.15752052,
									//0.16536100,	0.17453201,	0.18421552,	0.19441155,	0.20512008,	0.21634113,	0.22807468,	0.24032075,	0.25307932,	0.26635041,
									//0.28013400,	0.29443308,	0.30924520,	0.32457038,	0.34040860,	0.35675988,	0.37362420,	0.39100158,	0.40889200,	0.42729548,
									//0.44621200,	0.46350362,	0.48091956,	0.49845984,	0.51612444,	0.53391337,	0.55182664,	0.56986424,	0.58802616,	0.60631242,
									//0.62472300,	0.64167298,	0.65845912,	0.67508142,	0.69153988,	0.70783450,	0.72396528,	0.73993222,	0.75573532,	0.77137458,
									//0.78685000,	0.80056983,	0.81383640,	0.82664973,	0.83900980,	0.85091663,	0.86237020,	0.87337052,	0.88391760,	0.89401143,
									//0.90365200,	0.91293794,	0.92178856,	0.93020386,	0.93818384,	0.94572850,	0.95283784,	0.95951186,	0.96575056,	0.97155394,
									//0.97692200,	0.98139340,	0.98534560,	0.98877860,	0.99169240,	0.99408700,	0.99596240,	0.99731860,	0.99815560,	0.99847340,
									//0.99827200,	0.99909477,	0.99967896,	1.00002456,	1.00013157,	1.00000000,	0.99962984,	0.99902109,	0.99817376,	0.99708784,
									//0.96933300,	0.96968621,	0.96939004,	0.96844449,	0.96684956,	0.96460525,	0.96171156,	0.95816849,	0.95397604,	0.94913421,
									//0.94364300,	0.93529854,	0.92679444,	0.91813072,	0.90930736,	0.90032438,	0.89118176,	0.88187952,	0.87241764,	0.86279614,
									//0.85301500,	0.84329865,	0.83337280,	0.82323745,	0.81289260,	0.80233825,	0.79157440,	0.78060105,	0.76941820,	0.75802585,
									//0.74642400,	0.73403876,	0.72157156,	0.70902239,	0.69639124,	0.68367812,	0.67088304,	0.65800598,	0.64504696,	0.63200596,
									//0.61888300,	0.60489988,	0.59100772,	0.57720652,	0.56349628,	0.54987700,	0.53634868,	0.52291132,	0.50956492,	0.49630948,
									//0.48314500,	0.46961392,	0.45627548,	0.44312968,	0.43017652,	0.41741600,	0.40484812,	0.39247288,	0.38029028,	0.36830032,
									//0.35650300,	0.34461176,	0.33297684,	0.32159824,	0.31047596,	0.29961000,	0.28900036,	0.27864704,	0.26855004,	0.25870936,
									//0.24912500,	0.23993538,	0.23097132,	0.22223282,	0.21371988,	0.20543250,	0.19737068,	0.18953442,	0.18192372,	0.17453858,
									//0.16737900,	0.16065833,	0.15411580,	0.14775143,	0.14156520,	0.13555713,	0.12972720,	0.12407543,	0.11860180,	0.11330633,
									//0.10818900,	0.10341007,	0.09877368,	0.09427983,	0.08992852,	0.08571975,	0.08165352,	0.07772983,	0.07394868,	0.07031007,
									//0.06681400,	0.06363539,	0.06056044,	0.05758917,	0.05472156,	0.05195763,	0.04929736,	0.04674077,	0.04428784,	0.04193859,
									//0.03969300,	0.03772677,	0.03582516,	0.03398819,	0.03221584,	0.03050813,	0.02886504,	0.02728659,	0.02577276,	0.02432357,
									//0.02293900,	0.02170853,	0.02052280,	0.01938183,	0.01828560,	0.01723413,	0.01622740,	0.01526543,	0.01434820,	0.01347573,
									//0.01264800,	0.01194504,	0.01126904,	0.01062002,	0.00999796,	0.00940288,	0.00883476,	0.00829362,	0.00777944,	0.00729224,
									//0.00683200,	0.00645323,	0.00608932,	0.00574027,	0.00540608,	0.00508675,	0.00478228,	0.00449267,	0.00421792,	0.00395803,
									//0.00371300,	0.00351537,	0.00332536,	0.00314299,	0.00296824,	0.00280113,	0.00264164,	0.00248979,	0.00234556,	0.00220897,
									//0.00208000,	0.00197379,	0.00187184,	0.00177417,	0.00168076,	0.00159163,	0.00150676,	0.00142617,	0.00134984,	0.00127779,
									//0.00121000,	0.00115598,	0.00110412,	0.00105442,	0.00100688,	0.00096150,	0.00091828,	0.00087722,	0.00083832,	0.00080158,
									//0.00076700,	0.00073994,	0.00071384,	0.00068872,	0.00066456,	0.00064138,	0.00061916,	0.00059792,	0.00057764,	0.00055834,
									//0.00054000,	0.00052457,	0.00050968,	0.00049533,	0.00048152,	0.00046825,	0.00045552,	0.00044333,	0.00043168,	0.00042057,
									//0.00041000,	0.00040096,	0.00039224,	0.00038384,	0.00037576,	0.00036800,	0.00036056,	0.00035344,	0.00034664,	0.00034016,
									//0.00033400,	0.00033400,	0.00032937,	0.00032528,	0.00032173,	0.00031872,	0.00031625,	0.00031432,	0.00031293,	0.00031208,
									//0.00029000,};

	}

    public class MpiSPAM
    {
        public static double[] CublicSpline(double[] xInput, double[] yInput, double[] xOutput)
		{
             SPAM.CCoNumericalMethods NumericalMethod = new SPAM.CCoNumericalMethods();
             NumericalMethod.CreateNumericalMethods();
             return ((double[])NumericalMethod.cubicSpline(xInput, yInput, xOutput));
		}

        public static double CaculatePeakWavelength(int peakIndex,double[] xWave,double[] yCount,int curveFittingPoints)
        {
            int count =  2 * curveFittingPoints + 1;
			int moveIndex = 0;
            double[] x = new double[count];
            double[] y = new double[count];

			if (count > x.Length || count > y.Length)
				return 0.0d;

			if (x.Length != y.Length)
				return 0.0d;

            int dataLength =xWave.Length;

            for (int i = 0; i < count; i++)
            {
				moveIndex =  peakIndex - curveFittingPoints + i;
                if ( moveIndex <= (-1) )
                {
					x[i] = xWave[0] + ( xWave[1] - xWave[0]) * moveIndex ;
                    y[i] = yCount[0];
                }
				else if ( moveIndex >= dataLength)
				{
                    x[i] = xWave[dataLength - 1] + (xWave[dataLength - 1] - xWave[dataLength - 2]) * (moveIndex - dataLength + 1);
                    y[i] = yCount[dataLength - 1];
				}
				else
				{
					x[i] = xWave[moveIndex];
					y[i] = yCount[moveIndex];
				}
            }

            LstSquQuadRegr lstQuadRegr = new LstSquQuadRegr();

            for (int i = 0; i < x.Length; i++)
            {
                lstQuadRegr.AddPoints(x[i], y[i]);
            }
            return (lstQuadRegr.bTerm() / (-2 * lstQuadRegr.aTerm()));
        }

        public static double[] DoBoxCar(double[] array, int numberOfPixelsOnEitherSideOfCenter)
        {
            double sum = 0;
            int moveIndex = 0;
            double[] caculatedArray = new double[array.Length];

            for (int i = 0; i < array.Length; i++)
            {
                sum = array[i];

                for (int index = 1; index <= numberOfPixelsOnEitherSideOfCenter; index++)
                {
                    //decrease
                    moveIndex = i - index;
                    if (moveIndex < 0)
                    {
                        sum += array[0];
                    }
                    else
                    {
                        sum += array[moveIndex];
                    }

                    //increase
                    moveIndex = i + index;
                    if (moveIndex >= array.Length)
                    {
                        sum += array[array.Length - 1];
                    }
                    else
                    {
                        sum += array[moveIndex];
                    }
                }

                caculatedArray[i] = sum / (2 * numberOfPixelsOnEitherSideOfCenter + 1);
            }

            return caculatedArray;
        }

        public static double DoCorrectForDarkIntensity(ref double[] spectrumarray, double[] darkArray)
        {
            List<double> currentDarkAvgArray = new List<double>();
            List<double> refDarkAvgArray = new List<double>();
			double oldAvg = 0.0d;
			double newAvg = 0.0d;

            for (int i = 48; i < 2048; i = i + 50)
            {

                double sumDark1= 0;
                double sumDark2= 0;

                 for (int k = 0; k < 50; k++)
                 {
                     sumDark1= sumDark1+ spectrumarray[i + k];
                     sumDark2 = sumDark2 + darkArray[i + k];
                 }
                sumDark1=sumDark1/50;
                sumDark2=sumDark2/50;
                currentDarkAvgArray.Add(sumDark1);
                refDarkAvgArray.Add(sumDark2);     
            }

            currentDarkAvgArray.Sort();
            refDarkAvgArray.Sort();

            currentDarkAvgArray.ToArray();
            refDarkAvgArray.ToArray();

            double avgDark1 = currentDarkAvgArray[0] + currentDarkAvgArray[1] + currentDarkAvgArray[2] + currentDarkAvgArray[3];
            double avgDark2 = refDarkAvgArray[0] + refDarkAvgArray[1] + refDarkAvgArray[2] + refDarkAvgArray[3];

            double differentDarkAvg = 0.25* (avgDark1 - avgDark2);

            for (int i = 0; i < 2048; i++)
            {
				spectrumarray[i] = spectrumarray[i] - differentDarkAvg;
				if (i == 0)
				{
					oldAvg = spectrumarray[i];
					newAvg = spectrumarray[i];
				}
				else
				{
					newAvg = oldAvg + (spectrumarray[i] - oldAvg) / (double)i;
				}
			}

            return (avgDark1*0.25);
		}

		public static void CalcualteStartAndEndPixel(double[] wavelength, double startWave, double endWave, out int startPixel, out int endPixel)
		{
			startPixel = 0;
			endPixel = wavelength.Length - 1;

			//--- Use the default value return
			if ( endWave < startWave )
				return;

			//-- Search the pixel index in the every range
			for (int k = 0; k < wavelength.Length; k++)
			{
				if (  wavelength[ k ] < startWave )
				{
					startPixel = k;
				}

				if ( wavelength[ wavelength.Length - 1 - k ] >= endWave )
				{
					endPixel = wavelength.Length - 1 - k;
				}				
			}
			//--- Not find index for the start wave
			if ( startWave == wavelength[ wavelength.Length - 1 ] )
			{
				startPixel = wavelength.Length - 2;
			}
			//--- Not find index for the end wave
			if ( endWave == wavelength[ 0 ] )
			{
				endPixel = 1;
			}
			//--- When start value out of max range. ( default , startIndex = 0, out of min range )
			if ( startWave > wavelength[ wavelength.Length - 1 ] )
			{
				startPixel = wavelength.Length - 1;
			}
			//--- When end value out of min range. ( default , endIndex = max Index, out of max range )
			if ( endWave < wavelength[ 0 ] )
			{
				endPixel = 0;
			}		
		
		}

		public static int CalcMaxCount(double[] yArray, int startIndex, double yLowBoundValue)
		{
			return CalcMaxCount(yArray, startIndex, yArray.Length, yLowBoundValue);
		}

		public static int CalcMaxCount(double[] yArray, int startIndex, int endIndex,double yLowBoundValue)
		{
			if (startIndex < 0)
			{
				startIndex = 0;
			}

			if (endIndex > yArray.Length)
			{
				endIndex = yArray.Length;
			}

			for (int i = startIndex; i < endIndex; i++)
			{
				if (yArray[i] > yLowBoundValue)
				{
					yLowBoundValue = yArray[i];
					startIndex = i;
				}
			}
			return startIndex;
		}

		public static int FindPeakIndexBySmoothCurve(int indexPixel, double[] yArray)
		{
			if (indexPixel <= 20)
				return indexPixel;

			// (1) Smooth for the peak curve data again
			double[] PeakPicking = new double[41];
			for (int i = 0; i < 41; i++)
			{
				PeakPicking[i] = yArray[indexPixel - 20 + i];
			}

			PeakPicking = DoBoxCar(PeakPicking, 3);

			// indexPixel = indexPixel + CalcMaxCount(PeakPicking, 0, 5000) - 20 ;
			indexPixel = indexPixel + CalcMaxCount(PeakPicking, 11, 5000) - 20;

			return indexPixel;
		}

		private static double ComputeLuminousFluxLumen(double[] wavelength, double[] absSpectrum, out double[] weight, out double[] LmCm2PerWave, int mode)
		{
			double sum = 0.0d;
			double[] coefWave = null;
			double[] coefData = null;
			double interval = 1.0d;
			
			switch (mode)
			{
				case 0:
					coefData = Coef.yBarPer5nm;
					coefWave	= new double[Coef.yBarPer5nm.Length];
					interval = 5.0d;
					for (int i = 0; i < coefWave.Length; i++)
					{
						coefWave[i] = 380.0d + i * interval;
					}
					break;
				//------------------------------------------------------------------------------
				case 1:
					coefData = Coef.LuminousEfficiencyFunction1988Per5nm;
					coefWave	= new double[Coef.LuminousEfficiencyFunction1988Per5nm.Length];
					interval = 5.0d;
					for (int i = 0; i < coefWave.Length; i++)
					{
						coefWave[i] = 380.0d + i * interval;
					}
					break;
				//------------------------------------------------------------------------------
				case 2:
					coefData = Coef.LuminousEfficiencyFunction1988Per1nm;
					coefWave	= new double[Coef.LuminousEfficiencyFunction1988Per1nm.Length];
					interval = 1.0d;
					for (int i = 0; i < coefWave.Length; i++)
					{
						coefWave[i] = 380.0d + i * interval;
					}
					break;
				//------------------------------------------------------------------------------
				case 3:
					coefData = Coef.PDResponseByLag;
					coefWave = new double[Coef.PDResponseByLag.Length];
					interval = 1.0d;
					for (int i = 0; i < coefWave.Length; i++)
					{
						coefWave[i] = 380.0d + i * interval;
					}
					break;
				//------------------------------------------------------------------------------
                case 4:
                    coefData = Coef.PDResponseITRIPer10nm;
                    coefWave = new double[Coef.PDResponseITRIPer10nm.Length];
                    interval = 10.0d;
                    for (int i = 0; i < coefWave.Length; i++)
                    {
                        coefWave[i] = 380.0d + i * interval;
                    }
                    break;
                //------------------------------------------------------------------------------
                case 5:
                    coefData = Coef.PDResponseOptimumPer10nm;
                    coefWave = new double[Coef.PDResponseOptimumPer10nm.Length];
                    interval = 10.0d;
                    for (int i = 0; i < coefWave.Length; i++)
                    {
                        coefWave[i] = 380.0d + i * interval;
                    }
                    break;
                //------------------------------------------------------------------------------


				default:
					coefData = Coef.LuminousEfficiencyFunction1988Per1nm;
					coefWave	= new double[Coef.LuminousEfficiencyFunction1988Per1nm.Length];
					interval = 1.0d;
					for (int i = 0; i < coefWave.Length; i++)
					{
						coefWave[i] = 380.0d + i * interval;
					}
					break;
			}

			weight = new double[absSpectrum.Length];
			LmCm2PerWave = new double[absSpectrum.Length];
			int findIndex = -1;

			for (int i = 0; i < wavelength.Length; i++)
			{
				if (wavelength[i] < coefWave[0] || wavelength[i] > coefWave[ coefWave.Length - 1 ] )
				{
					weight[i] = 0.0d;
					continue;
				}

				for (int index = 0; index < (coefWave.Length - 1); index++)
				{
					if (wavelength[i] >= coefWave[index] && wavelength[i] < coefWave[ index + 1 ] )
					{
						findIndex = index;
						break;
					}
				}

				if (findIndex == -1 || findIndex == coefWave.Length )
				{
					weight[i] = 0.0d;
				}
				else if (findIndex == ( coefWave.Length - 1 ) && wavelength[i] == coefWave[ coefWave.Length - 1])
				{
					weight[i] = coefWave[ coefWave.Length - 1 ];
				}
				else
				{
					weight[i] = (coefData[findIndex + 1] - coefData[findIndex]) / interval * (wavelength[i] - coefWave[findIndex]) + coefData[findIndex];
					LmCm2PerWave[i] = weight[i] * absSpectrum[i] * 683.0d;
					if (LmCm2PerWave[i] < 0.0d)
					{
						LmCm2PerWave[i] = 0.0d;
					}

				}
				sum = sum + LmCm2PerWave[i];
			}

			return sum;
		}

		public static double ComputeLuminousFluxLumenA(double[] wavelength, double[] absSpectrum, out double[] weight, out double[] LmCm2PerWave)
		{
			return ComputeLuminousFluxLumen(wavelength, absSpectrum, out weight, out LmCm2PerWave, 0);				
		}

		public static double ComputeLuminousFluxLumenB(double[] wavelength, double[] absSpectrum, out double[] weight, out double[] LmCm2PerWave)
		{
			return ComputeLuminousFluxLumen(wavelength, absSpectrum, out weight, out LmCm2PerWave, 1);				
		}

		public static double ComputeLuminousFluxLumenC(double[] wavelength, double[] absSpectrum, out double[] weight, out double[] LmCm2PerWave)
		{
			return ComputeLuminousFluxLumen(wavelength, absSpectrum, out weight, out LmCm2PerWave, 2);
		}

		public static double ComputeLuminousFluxLumenD(double[] wavelength, double[] absSpectrum, out double[] weight, out double[] LmCm2PerWave)
		{
			return ComputeLuminousFluxLumen(wavelength, absSpectrum, out weight, out LmCm2PerWave, 3);
		}

        public static double ComputeLuminousFluxLumenE(double[] wavelength, double[] absSpectrum, out double[] weight, out double[] LmCm2PerWave)
        {
            return ComputeLuminousFluxLumen(wavelength, absSpectrum, out weight, out LmCm2PerWave, 4);
        }

		public static double NumericalIntgrateA(double[] x, double[] y, double startXvalue, double endXValue, EIntegrateMode mode, out double[] xyAreaValuePerPoint)
		{
			int startIndex = 0;
			int endIndex = x.Length;

			CalcualteStartAndEndPixel(x, startXvalue, endXValue, out startIndex, out endIndex);
			return NumericalIntgrateB(x, y, startIndex , endIndex, mode , out xyAreaValuePerPoint);			
		}

		public static double NumericalIntgrateB(double[] x, double[] y, int startXIndex, int endXIndex, EIntegrateMode mode, out double[] xyAreaValuePerPoint)
		{
			xyAreaValuePerPoint = new double[x.Length];
			double integrateSum = 0.0d;

			if ( x.Length != y.Length || startXIndex > endXIndex )
				return integrateSum;

			if ( startXIndex < 0 )
			{
				startXIndex = 0;
			}

			if ( endXIndex > x.Length )
			{
				endXIndex = x.Length;
			}

			switch ( mode )
			{
				case EIntegrateMode.RECTANGULAR :
						for (int i = startXIndex; i < endXIndex; i++)
						{
							xyAreaValuePerPoint[i] = y[i] * (x[i + 1] - x[i]);						// Left Reimann Sum
							//	xyAreaValuePerPoint[i] = y[ i + 1 ] * ( x[i + 1] - x[ i ] );		// Right Reimann Sum
							integrateSum += xyAreaValuePerPoint[i];
						}
					break;
				//-------------------------------------------------------------------------
				case EIntegrateMode.TRAPEZOID:
					for (int i = startXIndex; i < endXIndex; i++)
					{
						xyAreaValuePerPoint[i] = (y[i] + y[i + 1]) * (x[i + 1] - x[i]) / 2.0d;
						integrateSum += xyAreaValuePerPoint[i];
					}
					break;
				//-------------------------------------------------------------------------
				case EIntegrateMode.SIMPSONS:
	
					int n = endXIndex - startXIndex + 1 ;

					if (n < 3)
						return integrateSum = 0.0d;

					if ((n % 2) != 0)
					{
						for (int i = 0; i < (n - 1); i += 2)
						{
							integrateSum += (y[i] + 4 * y[i + 1] + y[i + 2]) * ( (x[i + 2] - x[i] ) ) / 6.0d;
						}
					}
					else
					{
						integrateSum = (x[3] - x[0]) * (y[0] + 3 * y[1] + 3 * y[2] + y[3]) / 8;
						for (int i = 3; i < n - 1; i += 2)
						{
							integrateSum += (y[i] + 4 * y[i + 1] + y[i + 2]) * ((x[i + 2] - x[i]) / 2.0d) / 3.0d;
						}
					
					}
				break;
				//-------------------------------------------------------------------------
				default:
					break;
			}
			
			return integrateSum;
		}

        //------------------------------------------
        //   20130221 Paul
        //   新增CCT演算法 McCamy法 (1992)
        //    n=(x-0.3320)/(y-0.1858)
        //    CCT=-437*n^3+3601*n^2-6861*n+5514.31
        //------------------------------------------          
        public static double ComputeCorrelatedColorTemperature(double cieX ,double cieY)
        {
            if (cieX < 0.001d)
            {
                return 0.0d;
            }

            double nFactor = (cieX - 0.3320) / (cieY - 0.1858);

            return (-437 * Math.Pow(nFactor, 3)) + (3601 * Math.Pow(nFactor, 2)) - (6861 * nFactor) + 5524.31;

           // return (-437 * Math.Pow(nFactor, 3)) + (3601 * Math.Pow(nFactor, 2)) - (6861 * nFactor) + 5514.31;
        }

        //------------------------------------------
        //   20130503 Paul
        //   新增uu,vv演算法
        //      this._CIE1976u = (4 * this._CIEx) / (3 - 2 * this._CIEx + 12 * this._CIEy);
        //       this._CIE1976v = (9 * this._CIEy) / (3 - 2 * this._CIEx + 12 * this._CIEy);
        //------------------------------------------          
        public static double ComputeUVprimeTemperature(double cieX, double cieY)
        {
            //this._CIE1976u = (4 * this._CIEx) / (3 - 2 * this._CIEx + 12 * this._CIEy);
            //this._CIE1976v = (9 * this._CIEy) / (3 - 2 * this._CIEx + 12 * this._CIEy);

            //double nFactor = (cieX - 0.3320) / (cieY - 0.1858);
            //return (-437 * Math.Pow(nFactor, 3)) + (3601 * Math.Pow(nFactor, 2)) - (6861 * nFactor) + 5514.31;
            return 0.0d;
        }

        public static double[] FilterData(double[] waveLength, double dividedWavelength, double[] data, double cutValue)
		{
			int indexPixel = 0;
			int UpindexPixel = 0;
			int LowindexPixel = 0;
			double filterValue = 0.0d;
			double[] outputData = new double[data.Length];

            if (((int)cutValue) == 0)
            {
                cutValue = 1.0;
            }

			indexPixel = CalcMaxCount(data, 0 , 0.0d);

            if (waveLength[indexPixel] < dividedWavelength)
            {
                return data;
            }

            filterValue = data[indexPixel] / cutValue;

			for (int i = indexPixel; i < data.Length; i++)
			{
				if (data[i] < filterValue)
				{
					UpindexPixel = i;
					break;
				}
			}
				
			for (int i = indexPixel; i >= 0 ; i--)
			{
				if (data[i] < filterValue)
				{
					LowindexPixel = i;
					break;
				}
			}

			for (int i = 0; i < outputData.Length; i++)
			{
				if (i > LowindexPixel && i < UpindexPixel)
				{
					outputData[i] = data[i];
				}
				else
				{
					outputData[i] = 0;
				}
			}
					
			return outputData;
			}

		private static SavitzkyGolayFilter _sgFilter = new SavitzkyGolayFilter();

        public static double[] SGFilter(double[] data, uint points, uint order)
        {
			return _sgFilter.filter(data, points, order);
        }
	 }	

    internal class SavitzkyGolayFilter
    {
        private double[] _coefSmoothing;

        public SavitzkyGolayFilter()
        {
        }

        #region >>> Public Method <<<

        public double[] filter(double[] data, uint points, uint order)
        {
            if (points % 2 == 0 || points < 5 || points > 25)
            {
                return data;
            }
            double[] tempSum = new double[data.Length];
            int halfWindow;
            this._coefSmoothing = new double[points];
            this.SGcoef(points, order);

            halfWindow = ((int)points - 1) / 2;

            for (int i = halfWindow; i < (data.Length - halfWindow); i++)
            {

                for (int j = 0; j < points; j++)
                {
                    tempSum[i] += this._coefSmoothing[j] * data[i - halfWindow + j];
                }

            }
            return tempSum;
        }

        #endregion

        #region >>> Private Method <<<

        private void SGcoef(uint points, uint order)
        {
            double[] tempCoef = null;
            int norm = 0;

            switch (points)
            {
                case 5:
                    tempCoef = new double[] { -3.0d, 12.0d, 17.0d, 12.0d, -3.0d };
                    norm = 35;
                    this.GenerateCoef(tempCoef, norm);
                    break;
				//------------------------------------------------------------------------------------------
                case 7:
                    tempCoef = new double[] { -2.0d, 3.0d, 6.0d, 7.0d, 6.0d, 3.0d, -2.0d };
                    norm = 21;
                    this.GenerateCoef(tempCoef, norm);
                    break;
				//------------------------------------------------------------------------------------------
                case 9:
                    tempCoef = new double[] { -21.0d, 14.0d, 39.0d, 54.0d, 59.0d, 54.0d, 39.0d, 14.0d, -21.0d };
                    norm = 231;
                    this.GenerateCoef(tempCoef, norm);
                    break;
				//------------------------------------------------------------------------------------------
                case 11:
                    tempCoef = new double[] {-36.0d, 9.0d, 44.0d, 69.0d, 84.0d, 89.0d, 
                                              84.0d, 69.0d, 44.0d, 9.0d, -36.0d };
                    norm = 429;
                    this.GenerateCoef(tempCoef, norm);
                    break;
				//------------------------------------------------------------------------------------------
                case 13:
                    tempCoef = new double[] {-11.0d, 0.0d, 9.0d, 16.0d, 21.0d, 24.0d, 25.0d,
                                              24.0d, 21.0d, 16.0d, 9.0d, 0.0d, -11.0d };
                    norm = 143;
                    this.GenerateCoef(tempCoef, norm);
                    break;
				//------------------------------------------------------------------------------------------
                case 15:
                    tempCoef = new double[] {-78.0d, -13.0d, 42.0d, 87.0d, 122.0d, 147.0d, 162.0d, 167.0d,
                                             162.0d, 147.0d, 122.0d, 87.0d, 42.0d, -13.0d, -78.0d };
                    norm = 1105;
                    this.GenerateCoef(tempCoef, norm);
                    break;
				//------------------------------------------------------------------------------------------
                case 17:
                    tempCoef = new double[] {-21.0d, -6.0d, 7.0d, 18.0d, 27.0d, 34.0d, 39.0d, 42.0d, 43.0d,
                                              42.0d, 39.0d, 34.0d, 27.0d, 18.0d, 7.0d, -6.0d, -21.0d };
                    norm = 323;
                    this.GenerateCoef(tempCoef, norm);
                    break;
				//------------------------------------------------------------------------------------------
                case 19:
                    tempCoef = new double[] {-136.0d, -51.0d, 24.0d, 89.0d, 144.0d, 189.0d, 224.0d, 249.0d, 264.0d, 269.0d,
                                              264.0d, 249.0d, 224.0d, 189.0d, 144.0d, 89.0d, 24.0d, -51.0d, -136.0d };
                    norm = 2261;
                    this.GenerateCoef(tempCoef, norm);
                    break;
				//------------------------------------------------------------------------------------------
                case 21:
                    tempCoef = new double[] {-171.0d, -76.0d, 9.0d, 84.0d, 149.0d, 204.0d, 249.0d, 284.0d, 309.0d, 324.0d, 329.0d,
                                             324.0d, 309.0d, 284.0d, 249.0d, 204.0d, 149.0d, 84.0d, 9.0d, -76.0d, -171.0d };
                    norm = 3059;
                    this.GenerateCoef(tempCoef, norm);
                    break;
				//------------------------------------------------------------------------------------------
                case 23:
                    tempCoef = new double[] {-42.0d, -21.0d, -2.0d, 15.0d, 30.0d, 43.0d, 54.0d, 63.0d, 70.0d, 75.0d, 78.0d, 79.0d,
                                              78.0d, 75.0d, 70.0d, 63.0d, 54.0d, 43.0d, 30.0d, 15.0d, -2.0d, -21.0d, -42.0d };
                    norm = 805;
                    this.GenerateCoef(tempCoef, norm);
                    break;
				//------------------------------------------------------------------------------------------
                case 25:
                    tempCoef = new double[] {-253.0d, -138.0d, -33.0d, 62.0d, 147.0d, 222.0d, 
                                              287.0d, 343.0d, 387.0d, 422.0d, 447.0d, 462.0d, 467.0d,
                                              462.0d, 447.0d, 422.0d, 387.0d, 343.0d, 287.0d, 
                                              222.0d, 147.0d, 62.0d, -33.0d, -138.0d, -253.0d };
                    norm = 5175;
                    this.GenerateCoef(tempCoef, norm);
                    break;
				//------------------------------------------------------------------------------------------
                default:
                    tempCoef = new double[] {-36.0d, 9.0d, 44.0d, 69.0d, 84.0d, 89.0d, 
                                              84.0d, 69.0d, 44.0d, 9.0d, -36.0d };
                    norm = 429;
                    this.GenerateCoef(tempCoef, norm);
                    break;
            }
        }

        private void GenerateCoef(double[] tempCoef, int norm)
        {
            for (int i = 0; i < tempCoef.Length; i++)
            {
                this._coefSmoothing[i] = tempCoef[i] / norm;
            }
        }

        #endregion

    }

    internal class LstSquQuadRegr
    {
        ArrayList pointArray = new ArrayList();
        private int numOfEntries;
        private decimal[] pointpair;

        public LstSquQuadRegr()
        {
            numOfEntries = 0;
            pointpair = new decimal[2];
        }

        public void Clear()
        {
            pointArray.Clear();
        }

        public void AddPoints(double x, double y)
        {
            pointpair = new decimal[2];
            numOfEntries += 1;
            pointpair[0] = Convert.ToDecimal(x);
            pointpair[1] = Convert.ToDecimal(y);
            pointArray.Add(pointpair);
        }

        /// <summary>
        /// returns the a term of the equation ax^2 + bx + c
        /// </summary>
        /// <returns>a term</returns>
        private decimal deciATerm()
        {
            if (numOfEntries < 3)
            {
                throw new InvalidOperationException("Insufficient pairs of co-ordinates");
            }
            //notation sjk to mean the sum of x_i^j*y_i^k. 
            decimal s40 = getSxy(4, 0);
            decimal s30 = getSxy(3, 0);
            decimal s20 = getSxy(2, 0);
            decimal s10 = getSxy(1, 0);
            decimal s00 = numOfEntries;

            decimal s21 = getSxy(2, 1);
            decimal s11 = getSxy(1, 1);
            decimal s01 = getSxy(0, 1);

            //   Da / D
            return (s21 * (s20 * s00 - s10 * s10) - s11 * (s30 * s00 - s10 * s20) + s01 * (s30 * s10 - s20 * s20))
                    /
                    (s40 * (s20 * s00 - s10 * s10) - s30 * (s30 * s00 - s10 * s20) + s20 * (s30 * s10 - s20 * s20));
        }

        public double aTerm()
        {
            return Convert.ToDouble(deciATerm());
        }

        private decimal deciBTerm()
        {
            if (numOfEntries < 3)
            {
                throw new InvalidOperationException("Insufficient pairs of co-ordinates");
            }
            //notation sjk to mean the sum of x_i^j*y_i^k. 
            decimal s40 = getSxy(4, 0);
            decimal s30 = getSxy(3, 0);
            decimal s20 = getSxy(2, 0);
            decimal s10 = getSxy(1, 0);
            decimal s00 = numOfEntries;

            decimal s21 = getSxy(2, 1);
            decimal s11 = getSxy(1, 1);
            decimal s01 = getSxy(0, 1);

            //   Db / D
            return (s40 * (s11 * s00 - s01 * s10) - s30 * (s21 * s00 - s01 * s20) + s20 * (s21 * s10 - s11 * s20))
            /
            (s40 * (s20 * s00 - s10 * s10) - s30 * (s30 * s00 - s10 * s20) + s20 * (s30 * s10 - s20 * s20));
        }

        public double bTerm()
        {
            return Convert.ToDouble(deciBTerm());
        }

        private decimal deciCTerm()
        {
            if (numOfEntries < 3)
            {
                throw new InvalidOperationException("Insufficient pairs of co-ordinates");
            }
            //notation sjk to mean the sum of x_i^j*y_i^k.  
            decimal s40 = getSxy(4, 0);
            decimal s30 = getSxy(3, 0);
            decimal s20 = getSxy(2, 0);
            decimal s10 = getSxy(1, 0);
            decimal s00 = numOfEntries;

            decimal s21 = getSxy(2, 1);
            decimal s11 = getSxy(1, 1);
            decimal s01 = getSxy(0, 1);

            //   Dc / D
            return (s40 * (s20 * s01 - s10 * s11) - s30 * (s30 * s01 - s10 * s21) + s20 * (s30 * s11 - s20 * s21))
                    /
                    (s40 * (s20 * s00 - s10 * s10) - s30 * (s30 * s00 - s10 * s20) + s20 * (s30 * s10 - s20 * s20));
        }

        public double cTerm()
        {
            return Convert.ToDouble(deciCTerm());
        }

        public double rSquare() // get rsquare
        {
            if (numOfEntries < 3)
            {
                throw new InvalidOperationException("Insufficient pairs of co-ordinates");
            }
            return Convert.ToDouble(1 - getSSerr() / getSStot());
        }

        /*helper methods*/
        private decimal getSxy(int xPower, int yPower) // get sum of x^xPower * y^yPower
        {
            decimal Sxy = 0;
            foreach (decimal[] ppair in pointArray)
            {
                decimal xToPower = 1;
                for (int i = 0; i < xPower; i++)
                {
                    xToPower = xToPower * ppair[0];
                }

                decimal yToPower = 1;
                for (int i = 0; i < yPower; i++)
                {
                    yToPower = yToPower * ppair[1];
                }
                Sxy += xToPower * yToPower;
            }
            return Sxy;
        }

        private decimal getYMean()
        {
            decimal y_tot = 0;
            foreach (decimal[] ppair in pointArray)
            {
                y_tot += ppair[1];
            }
            return y_tot / numOfEntries;
        }

        private decimal getSStot()
        {
            decimal ss_tot = 0;
            foreach (decimal[] ppair in pointArray)
            {
                ss_tot += (ppair[1] - getYMean()) * (ppair[1] - getYMean());
            }
            return ss_tot;
        }

        private decimal getSSerr()
        {
            decimal ss_err = 0;
            foreach (decimal[] ppair in pointArray)
            {
                ss_err += (ppair[1] - getPredictedY(ppair[0])) * (ppair[1] - getPredictedY(ppair[0]));
            }
            return ss_err;
        }

        private decimal getPredictedY(decimal x)
        {
            return deciATerm() * x * x + deciBTerm() * x + deciCTerm();
        }

    }

}
